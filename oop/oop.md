# oop
## 理解对象
- 对象的属性类型
  - 数据属性
  - 访问器属性
    - getter函数，读取访问器的属性
    - setter函数，写入访问器的属性
- 定义多个对象
- 读取对象的属性
## 创建对象 
- 工厂模式
  - 没有解决了对象识别的问题
  - 解决了创建多个相似对象的问题
- 构造函数模式
  - 与工厂模式的区别
    - 没有显式地创建对象
    - 直接将属性和方法赋给了this对象
    - 没有return语句
  - 构造函数始终以一个大写字母开头
  - 主要有4个步骤
    - 创建一个新的对象
    - 将构造函数的作用域赋给新对象（this指向这个新对象）
    - 执行构造函数中的代码（给对象添加新属性）
    - 返回新对象
  - 缺点
    - 对象里面的方法都要在每一个实例上重新创建一遍
    - 没有封装性可言
- 原型模式
  - 理解原型对象
    - 每创建一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性
    - 默认情况下原型对象对自动获得一个construor属性，这个属性是指向prototype属性所在函数的指针
    - 可以用isPrototypeOf()来判断对象之间是否存在原型的关系，返回值是Boolean
    - 调用原型上的方法，会执行两次搜索，第一次先询问实例函数，第二次再去询问原型
    - 使用hasOwnPrototype()可以用来检测一个属性是否存在实例中
  - 原型与in操作符
    - 单独使用
      - in操作符用来判断属性是否存在对象中，无论存在实例还是原型上。
    - for-in循环使用
      - 返回所有能够通过对象访问、可枚举的属性
      其中包括了原型上的属性和实例上的属性
      - 可以用Object.keys()和Object.getOwnPropertyNames()来替代fon-in
  - 更简单的原型语法
    - 再函数的原型上设置属性时，constructor属性不会再指向该函数
  - 原型的动态性
    - 重写原型对象会切断现有原型和任何之前已经存在的对象实例之间的联系
  - 原生对象的原型
  - 原型对象的问题
   - 省略了为构造函数传递初始化参数的环节
   - 其共享的属性导致了实例化函数属性的污染
- 组合使用构造函数模式和原型模式
  - 每一个实例都会有自己的一份实例属性的副本，但是同时又共享着对方的引用
  - 认同度最高的一种创建自定义类型的方法，是定义引用类型的一种默认形式
- 动态原型模式
- 寄生构造函数模式
- 稳妥构造函数模式
